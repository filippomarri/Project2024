<html>
    <head></head>
    <body>
        <div id="container">
            <h1>Scriabin's Chromesthesia</h1>
            <p>Drag and Drop and image, paste it, or use the upload bar below</p>
            <div>
                <input id="getfile" type="file" />
                <label for="getfile">Upload an image</label>
            </div>
            <div id="imagecontainer"></div>
            <output></output>
        </div>

        <style>
            html, body {
                height: 100%;
                display: block;
                margin: 0;
                padding: 0;
                font-family: Arial, Helvetica, sans-serif;
            }
            h1 {
                margin: 0;
                padding: 10px 0;
            }
            #container {
                height: 100%;
                padding: 0 20px;
                display: block;
                background: honeydew;
                }
            label {
                display: block;
                padding: 5px 10px;
                background: seagreen;
            }
            [type="file"] {
                border: 0;
                clip: rect(0, 0, 0, 0);
                height: 1px;
                overflow: hidden;
                padding: 0;
                position: absolute !important;
                white-space: nowrap;
                width: 1px;
            }
            [type="file"]:focus + label,
            [type="file"] + label:hover {
                background-color: green;
                display: block;
            }
            [type="file"]:focus + label {
                outline: 1px dotted #000;
            }  
            output {
                display: block;
                padding: 5px 10px;
            }
        </style>

        <script>
            //Model
            var img = new Image();

            function upload_image(){
                const fileinput = document.querySelector('#getfile');
                const output = document.querySelector('output');
                const imagecontainer = document.querySelector('#imagecontainer');
 
                /* Show the image once we have it */
                const loadImage = (file, name) => {
                    if (name) {
                        output.innerText = 'Filename: ' + name;
                    }
                    img.src = file;
                    img.onload = function() {
                        imagecontainer.appendChild(img);
                    };
                }
 
                /* Image from Clipboard */
                const getClipboardImage = (ev) => {
                    let items = ev.clipboardData.items;
                    for (var i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf('image') !== -1) {
                            var blob = items[i].getAsFile();
                            loadImage(window.URL.createObjectURL(blob));
                            break;
                        }
                    }
                }
                window.addEventListener('paste', getClipboardImage, false);

                /* Image from Drag and Drop */
                const imageFromDrop = (e) => {
                    var file = e.dataTransfer.files[0];
                    loadImage(window.URL.createObjectURL(file), file.name);
                    e.preventDefault();
                }
                container.addEventListener('drop', imageFromDrop, false);
                // Override the normal drag and drop behaviour
                container.addEventListener('dragover', (ev) => {
                    ev.preventDefault();
                }, false);

                /* Image from Upload */
                const imageFromUpload = (e) => {
                    var file = e.target.files[0];
                    loadImage(window.URL.createObjectURL(file), file.name);
                    e.preventDefault();
                }
                fileinput.addEventListener('change', imageFromUpload, false);

            };

            function pickColours (cropped_image){
                /*The function takes as input an image and it returns a vector with its averaged RGB composition*/
                let blockSize = 5; // only visit every 5 pixels
                const defaultRGB = {r:0,g:0,b:0}; // for non-supporting envs returns black
                let canvas = document.createElement('canvas');  //creates a Canvas
                let context = canvas.getContext && canvas.getContext('2d'); //creates the context
                let data;
                let width;
                let height;
                let i = -4;
                let length;
                let rgb = {r:0,g:0,b:0};  //initilise the vector that will be returned
                let count = 0;      //counter for the average

                if (!context) {         //if the context is empty (context == 0), returns black
                    return defaultRGB;
                }
                
                //naturalHeight returns the real height of the image in pixels. It is the height that the image would have if it was not squeezed into any container
                //offsetHeight returns the height of the image including vertical passing, borders and so on.
                //height simply returns the height of the image.
                //the chain of or returns the higher value between the three with a certain error (we don't want precision here)
                height = canvas.height = cropped_image.naturalHeight || cropped_image.offsetHeight || cropped_image.height;
                width = canvas.width = cropped_image.naturalWidth || cropped_image.offsetWidth || cropped_image.width;

                context.drawImage(cropped_image, 0, 0); //It draws the image in the context

                try {   //it tests for errors the statement
                    data = context.getImageData(0, 0, width, height);
                } catch(e) {    //if there are some errors, it returns black (the e stands for error)
                /* security error, img on diff domain */
                    return defaultRGB;
                }

                length = data.data.length;  //we define length as the length of the array where we have saved the data image

                while ( (i += blockSize * 4) < length ) {   //we sum the amount of red, green and blue in each part
                    ++count;
                    rgb.r += data.data[i];
                    rgb.g += data.data[i+1];
                    rgb.b += data.data[i+2];
                }

                // ~~ used to floor values
                rgb.r = ~~(rgb.r/count);    //we evaluate the average
                rgb.g = ~~(rgb.g/count);
                rgb.b = ~~(rgb.b/count);

                return rgb;

            }
            
            upload_image();
        </script>
    </body>
</html>