<html>
    <head></head>
    <body>
        <div id="container">

            <h1>What is the sound of colours?</h1>

            <label for="imageInput" id="imageInputLabel">Upload Image</label>
            <input type="file" id="imageInput" accept="image/*">

            <canvas id="myCanvas"></canvas>
            <button id="toggleButton">Start Animation</button>
            <input type="range" id="speedSlider" min="1" max="15" value="1">
        </div>

        <style>
            h1 {
                margin: 0;
                padding: 10px 0;
                font-family: "Didot";
                src: url("https://applesocial.s3.amazonaws.com/assets/styles/fonts");
                text-align: center;
                color: white;
            }

            body {
                background-color: black;
                text-align: center;
            }

            canvas {
                border: 1px solid silver;
                padding-left: 0;
                padding-right: 0;
                margin-left: auto;
                margin-right: auto;
                display: block;
                backdrop-filter: url(commonfilters.svg#filter);
                background-image: url('tumblr_0962d4573c83f7d0a3a6792871aa8cc4_5d2f4f21_400.gif');
                font-family: "Didot";
                font-weight: 500;
                src: url("https://applesocial.s3.amazonaws.com/assets/styles/fonts");
                display: block;
                background-repeat: no-repeat;
                background-size: cover;
                -webkit-filter: blur(20px);
                -moz-filter: blur(20px);
                -o-filter: blur(20px);
                -ms-filter: blur(20px);
                filter: blur(20px);
            }

            #toggleButton,
            #imageInputLabel,
            h1 {
                font-family: 'Arial', sans-serif; /* Set the same font for both elements */
            }

            #toggleButton {
                padding: 10px;
                font-size: 16px;
                background-color: white;
                color: black;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                margin-top: 10px;
            }

            #imageInput {
                display: none; /* Hide the default file input */
                padding: 10px;
                margin-top: 10px;
                background-color: white;
                color: black;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
                margin-bottom: 10px;
            }

            #imageInputLabel {
                display: inline-block;
                background-color: white;
                color: black;
                padding: 10px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
                margin-bottom: 10px;
            }

            #speedSlider {
                width: 100%;
                margin-top: 10px;
            }
        </style>

        <script>
            //INITIALSATION
            // Get the canvas and context
            const canvas = document.getElementById('myCanvas');
            const ctx = canvas.getContext('2d');

            // Input element for uploading background image
            const imageInput = document.getElementById('imageInput');

            //MODEL
            // Animation variables
            let animationId;
            let isAnimating = false;
            let x = 0; // Initial position
            let speed = 0.5; // Initial speed
            let backgroundImage;

            //VIEW
            // Function to upload the image in the canvas
            imageInput.addEventListener('change', handleImageUpload);

            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        backgroundImage = new Image();
                        backgroundImage.src = e.target.result;
                        backgroundImage.onload = function () {
                            resizeCanvas(); // Adjust the canvas size when a new image is loaded
                        };
                    };
                    reader.readAsDataURL(file);
                }
            }

            // Function to animate the line
            function animateLine() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the background image with margins if necessary
                if (backgroundImage) {
                    const maxImageWidth = canvas.width; // Adjust the margin as needed
                    const maxImageHeight = canvas.height; // Adjust the margin as needed

                    const aspectRatio = backgroundImage.width / backgroundImage.height;

                    let imgWidth = maxImageWidth;
                    let imgHeight = imgWidth / aspectRatio;

                    if (imgHeight > maxImageHeight) {
                        imgHeight = maxImageHeight;
                        imgWidth = imgHeight * aspectRatio;
                    }

                    const xPosition = (canvas.width - imgWidth) / 2;
                    const yPosition = (canvas.height - imgHeight) / 2;

                    ctx.drawImage(backgroundImage, xPosition, yPosition, imgWidth, imgHeight);

                    //  QUESTO NON FUNZIONA NON SO PERCHÃ©
                    // x = (canvas.width - imgWidth) / 2;

                    // Draw a moving line within the image borders
                    ctx.beginPath();
                    ctx.moveTo(x, (canvas.height - imgHeight) / 2);
                    const lineHeight = imgHeight;
                    ctx.lineTo(x, (canvas.height - imgHeight) / 2 + lineHeight);
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    ctx.closePath();

                    // Update the position for the next frame
                    x += speed;

                    // Check if the line has reached the right border of the image
                    if (x > (canvas.width + imgWidth) / 2) {
                        x = (canvas.width - imgWidth) / 2; // Return to the left side of the image
                        isAnimating = false;
                        toggleButton.textContent = 'Start Animation';
                    }

                    // Request the next animation frame
                    if (isAnimating) {
                        animationId = requestAnimationFrame(animateLine);
                    }
                } else { // If the image is not loaded

                    // Draw a moving line
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    const lineHeight = canvas.height;
                    ctx.lineTo(x, lineHeight);

                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    ctx.closePath();

                    // Update the position for the next frame
                    x += speed;

                    // Check if the line has reached the right border
                    if (x > canvas.width) {
                        x = 0; // Return to the left side
                        isAnimating = false;
                        toggleButton.textContent = 'Start Animation';
                    }

                    // Request the next animation frame
                    if (isAnimating) {
                        animationId = requestAnimationFrame(animateLine);
                    }
                }
            }

            // Toggle button
            const toggleButton = document.getElementById('toggleButton');
            toggleButton.addEventListener('click', () => {
                if (!isAnimating) {
                    // Start the animation
                    isAnimating = true;
                    toggleButton.textContent = 'Stop Animation';
                    animateLine();
                } else {
                    // Stop the animation
                    cancelAnimationFrame(animationId);
                    isAnimating = false;
                    toggleButton.textContent = 'Start Animation';
                }
            });

            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            speedSlider.addEventListener('input', (event) => {
                speed = parseInt(event.target.value, 10)*0.5;
            });

            // Resize canvas when the window is resized
            function resizeCanvas() {
                canvas.width = window.innerWidth - 200;
                canvas.height = window.innerHeight - 200;
                drawCanvas();
            }

            function drawCanvas() {
                // Redraw the background image and any other elements here
                if (backgroundImage) {
                    const maxImageWidth = canvas.width; // Adjust the margin as needed
                    const maxImageHeight = canvas.height; // Adjust the margin as needed

                    const aspectRatio = backgroundImage.width / backgroundImage.height;

                    let imgWidth = maxImageWidth;
                    let imgHeight = imgWidth / aspectRatio;

                    if (imgHeight > maxImageHeight) {
                        imgHeight = maxImageHeight;
                        imgWidth = imgHeight * aspectRatio;
                    }

                    const xPosition = (canvas.width - imgWidth) / 2;
                    const yPosition = (canvas.height - imgHeight) / 2;

                    ctx.drawImage(backgroundImage, xPosition, yPosition, imgWidth, imgHeight);

                    // Start from the image left border
                    x = (canvas.width - imgWidth) / 2;
                }
            }

            function pickColours (cropped_image){
                /*The function takes as input an image and it returns a vector with its averaged RGB composition*/
                let blockSize = 5; // only visit every 5 pixels
                const defaultRGB = {r: 0, g: 0, b: 0}; // for non-supporting envs returns black
                let canvas = document.createElement('canvas');  //creates a Canvas
                let context = canvas.getContext && canvas.getContext('2d'); //creates the context
                let data;
                let width;
                let height;
                let i = -4;
                let length;
                let rgb = {r: 0, g: 0, b: 0};  //initilise the vector that will be returned
                let count = 0;      //counter for the average

                if (!context) {         //if the context is empty (context == 0), returns black
                    return defaultRGB;
                }
                
                //naturalHeight returns the real height of the image in pixels. It is the height that the image would have if it was not squeezed into any container
                //offsetHeight returns the height of the image including vertical passing, borders and so on.
                //height simply returns the height of the image.
                //the chain of or returns the higher value between the three with a certain error (we don't want precision here)
                height = canvas.height = cropped_image.naturalHeight || cropped_image.offsetHeight || cropped_image.height;
                width = canvas.width = cropped_image.naturalWidth || cropped_image.offsetWidth || cropped_image.width;

                context.drawImage(cropped_image, 0, 0); //It draws the image in the context

                try {   //it tests for errors the statement
                    data = context.getImageData(0, 0, width, height);
                } catch(e) {    //if there are some errors, it returns black (the e stands for error)
                /* security error, img on diff domain */
                    return defaultRGB;
                }

                length = data.data.length;  //we define length as the length of the array where we have saved the data image

                while ( (i += blockSize * 4) < length ) {   //we sum the amount of red, green and blue in each part
                    ++count;
                    rgb.r += data.data[i];
                    rgb.g += data.data[i+1];
                    rgb.b += data.data[i+2];
                }

                // ~~ used to floor values
                rgb.r = ~~(rgb.r/count);    //we evaluate the average
                rgb.g = ~~(rgb.g/count);
                rgb.b = ~~(rgb.b/count);

                return rgb;

            }

            window.addEventListener('resize', resizeCanvas);

            // Initial canvas setup
            resizeCanvas();
        </script>
    </body>
</html>